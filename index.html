<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="style.css">
        <link rel="icon" type="image/jpg" href="devglogo.png">
        <title>devGaming - ChatMagician</title>
    </head>
    <body>
        <div id="info_icon" class="info_icon">
            ‚ÑπÔ∏è
            <div class="tooltip">
                <div class="tooltip_title">Formatowanie tekstu</div>
                <div class="tooltip_item"><span class="color_box" style="background-color: #fbf724;"></span> Zawiera "(telefon)" ‚Üí Yellow</div>
                <div class="tooltip_item"><span class="color_box" style="background-color: #56d64b;"></span> Zawiera "$number" ‚Üí Green</div>
                <div class="tooltip_item"><span class="color_box" style="background-color: #979aed;"></span> Zaczyna siƒô od "**" ‚Üí Purple</div>
                <div class="tooltip_item"><span class="color_box" style="background-color: #c2a3da;"></span> Zaczyna siƒô od "*" ‚Üí Pink</div>
                <div class="tooltip_item"><span class="color_box" style="background-color: #f1f1f1;"></span> Zwyk≈Çy tekst ‚Üí White</div>
                <div class="tooltip_title" style="margin-top: 12px;">Skr√≥ty klawiszowe</div>
                <div class="tooltip_item">üñ±Ô∏è <b>LPM</b> na tek≈õcie ‚Üí PrzeciƒÖgnij tekst</div>
                <div class="tooltip_item">üñ±Ô∏è <b>PPM</b> lub <b>Shift + LPM</b> ‚Üí PrzeciƒÖgnij obraz</div>
                <div class="tooltip_item">üñ±Ô∏è <b>Ctrl + LPM</b> + przeciƒÖgnij ‚Üí Kadruj obraz</div>
                <div class="tooltip_item">üñ±Ô∏è <b>Alt + Scroll</b> ‚Üí Skaluj obraz</div>
            </div>
        </div>
        <div class="main">
            <div id="chat_editor">
                <center>
                    <div id="settings_container">
                        <div>
                            <label for="font_size">Rozmiar:</label>
                            <input type="number" id="font_size" min="8" max="48" value="12">
                            <span id="font_size_display">12px</span>
                        </div>
                        <div>
                            <label for="font_family">Czcionka:</label>
                            <select id="font_family">
                                <option value="Arial">Arial</option>
                                <option value="Verdana">Verdana</option>
                                <option value="Times New Roman">Times New Roman</option>
                                <option value="Courier New">Courier New</option>
                                <option value="Georgia">Georgia</option>
                                <option value="Trebuchet MS">Trebuchet MS</option>
                                <option value="Comic Sans MS">Comic Sans MS</option>
                                <option value="Impact">Impact</option>
                                <option value="Tahoma">Tahoma</option>
                            </select>
                        </div>
                        <div>
                            <label for="bg_color">T≈Ço:</label>
                            <input type="color" id="bg_color" value="#161616">
                        </div>
                        <div>
                            <label for="custom_color">Kolor:</label>
                            <input type="color" id="custom_color" value="#a6a6a6">
                        </div>
                        <div>
                            <label for="process_text">
                                <input type="checkbox" id="process_text">
                                Logi z chatu
                            </label>
                        </div>
                    </div>
                    <div id="text_blocks_container" style="display:none;">
                        <div id="text_blocks_list"></div>
                        <button id="add_text_block">+ Dodaj tekst</button>
                    </div>
                    <div id="input_container">
                        <textarea id="user_input" placeholder="Wpisz swojƒÖ wiadomo≈õƒá tutaj..."></textarea>
                    </div>
                    <div id="image_add_container">
                        <input type="file" id="bg_image" accept="image/*" style="display:none;">
                        <button id="bg_image_btn" class="file-button">+ Dodaj obraz</button>
                        <button id="clear_all_images" style="display:none;">Usu≈Ñ wszystkie</button>
                    </div>
                    <div id="images_container" style="display:none;">
                        <div id="images_list"></div>
                    </div>
                    <div id="image_size_controls" style="display:none;">
                        <label for="image_width">Rozmiar:</label>
                        <input type="number" id="image_width" min="100" max="4000" value="800">
                        <span>x</span>
                        <input type="number" id="image_height" min="100" max="4000" value="600">
                        <button id="apply_size">Zastosuj</button>
                        <label for="text_bg_enabled" style="margin-left: 10px;">
                            <input type="checkbox" id="text_bg_enabled">
                            T≈Ço tekstu
                        </label>
                        <label for="multi_text_enabled" style="margin-left: 10px;">
                            <input type="checkbox" id="multi_text_enabled">
                            Wiele tekst√≥w
                        </label>
                    </div>
                    <div id="image_effects_controls" style="display:none;">
                        <div class="effect-row">
                            <label>Rozmycie: <span id="blur_value">0</span>px</label>
                            <input type="range" id="effect_blur" min="0" max="20" value="0" step="1">
                        </div>
                        <div class="effect-row">
                            <label>Kontrast: <span id="contrast_value">100</span>%</label>
                            <input type="range" id="effect_contrast" min="0" max="200" value="100" step="5">
                        </div>
                        <div class="effect-row">
                            <label>Nasycenie: <span id="saturation_value">100</span>%</label>
                            <input type="range" id="effect_saturation" min="0" max="200" value="100" step="5">
                        </div>
                        <div class="effect-row">
                            <label>Jasno≈õƒá: <span id="brightness_value">100</span>%</label>
                            <input type="range" id="effect_brightness" min="0" max="200" value="100" step="5">
                        </div>
                        <div class="effect-row">
                            <label>Ziarno: <span id="grain_value">0</span>%</label>
                            <input type="range" id="effect_grain" min="0" max="100" value="0" step="5">
                        </div>
                        <button id="reset_effects">Resetuj</button>
                    </div>
                    <div id="preview_container">
                        <canvas id="preview_canvas"></canvas>
                    </div>
                    <div id="button_container">
                        <button id="dwnl_trs">Pobierz przezroczysty</button>
                        <button id="dwnl_bcg">Pobierz z t≈Çem</button>
                        <button id="dwnl_img" style="display:none;">Pobierz z obrazem</button>
                    </div>
                    <div id="chat_container">
                        <div id="chat_messages">

                        </div>
                    </div>
                </center>
                
            </div>
        </div>

        <script>
            // --- DOM Elements ---
            const previewCanvas = document.getElementById('preview_canvas');
            const userInput = document.getElementById('user_input');
            const bgImageInput = document.getElementById('bg_image');
            const bgImageBtn = document.getElementById('bg_image_btn');
            const customColorInput = document.getElementById('custom_color');
            const fontSizeInput = document.getElementById('font_size');
            const fontSizeDisplay = document.getElementById('font_size_display');
            const bgColorInput = document.getElementById('bg_color');
            const textBgEnabledCheckbox = document.getElementById('text_bg_enabled');
            const fontFamilyInput = document.getElementById('font_family');
            const processTextCheckbox = document.getElementById('process_text');
            const chatMessages = document.getElementById('chat_messages');
            const dwnlTrsBtn = document.getElementById('dwnl_trs');
            const dwnlBcgBtn = document.getElementById('dwnl_bcg');
            const dwnlImgBtn = document.getElementById('dwnl_img');
            const clearAllImagesBtn = document.getElementById('clear_all_images');
            const imageSizeControls = document.getElementById('image_size_controls');
            const imageWidthInput = document.getElementById('image_width');
            const imageHeightInput = document.getElementById('image_height');
            const applySizeBtn = document.getElementById('apply_size');
            const imageEffectsControls = document.getElementById('image_effects_controls');
            const effectBlur = document.getElementById('effect_blur');
            const effectContrast = document.getElementById('effect_contrast');
            const effectSaturation = document.getElementById('effect_saturation');
            const effectBrightness = document.getElementById('effect_brightness');
            const resetEffectsBtn = document.getElementById('reset_effects');
            const blurValue = document.getElementById('blur_value');
            const contrastValue = document.getElementById('contrast_value');
            const saturationValue = document.getElementById('saturation_value');
            const brightnessValue = document.getElementById('brightness_value');
            const effectGrain = document.getElementById('effect_grain');
            const grainValue = document.getElementById('grain_value');
            const textBlocksContainer = document.getElementById('text_blocks_container');
            const textBlocksList = document.getElementById('text_blocks_list');
            const addTextBlockBtn = document.getElementById('add_text_block');
            const multiTextCheckbox = document.getElementById('multi_text_enabled');
            const inputContainer = document.getElementById('input_container');
            const imagesContainer = document.getElementById('images_container');
            const imagesList = document.getElementById('images_list');

            // --- State Variables ---
            let backgroundImg = null;
            let originalBackgroundImg = null;
            let textPosition = { x: 50, y: 100 };
            let imagePosition = { x: 0, y: 0 };
            let viewportSize = { width: 800, height: 600 };
            let isDragging = false;
            let isImageDragging = false;
            let dragOffset = { x: 0, y: 0 };
            let imageEffects = { blur: 0, contrast: 100, saturation: 100, brightness: 100, grain: 0 };
            
            // Multiple images state
            let images = []; // Array of { id, img, x, y, cropX, cropY, cropW, cropH, origW, origH, name }
            let selectedImageId = null;
            let imageIdCounter = 0;
            let isCropping = false;
            let cropStart = { x: 0, y: 0 };
            let cropEnd = { x: 0, y: 0 };
            
            // Multi-text state
            let textBlocks = [];
            let selectedTextBlockId = null;
            let textBlockIdCounter = 0;

            // Settings
            let settings = {
                fontSize: 12,
                fontFamily: 'Arial',
                bgColor: '#161616',
                maxWidth: 1200
            };

            // --- FUNCTIONS (defined first) ---
            
            // Function to apply grain effect with colored dots (white, red, blue)
            function applyGrain(ctx, width, height, intensity) {
                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;
                const grainDensity = intensity / 100; // How many pixels get grain
                
                for (let i = 0; i < data.length; i += 4) {
                    // Only apply grain to some pixels based on density
                    if (Math.random() < grainDensity * 0.3) {
                        const grainType = Math.random();
                        const brightness = 20 + Math.random() * 40; // Smaller, subtler dots
                        
                        if (grainType < 0.4) {
                            // White dot
                            data[i] = Math.min(255, data[i] + brightness);
                            data[i + 1] = Math.min(255, data[i + 1] + brightness);
                            data[i + 2] = Math.min(255, data[i + 2] + brightness);
                        } else if (grainType < 0.6) {
                            // Red dot
                            data[i] = Math.min(255, data[i] + brightness);
                        } else if (grainType < 0.8) {
                            // Blue dot
                            data[i + 2] = Math.min(255, data[i + 2] + brightness);
                        } else {
                            // Green dot (for RGB mix)
                            data[i + 1] = Math.min(255, data[i + 1] + brightness * 0.7);
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
            }
            
            // Image management functions
            function addImage(img, name) {
                const id = ++imageIdCounter;
                images.push({
                    id,
                    img,
                    x: 0,
                    y: 0,
                    cropX: 0,
                    cropY: 0,
                    cropW: img.width,
                    cropH: img.height,
                    origW: img.width,
                    origH: img.height,
                    scale: 1,
                    name: name || `Obraz ${id}`
                });
                
                // Show controls on first image
                if (images.length === 1) {
                    viewportSize = { width: img.width, height: img.height };
                    imageWidthInput.value = img.width;
                    imageHeightInput.value = img.height;
                    clearAllImagesBtn.style.display = 'inline';
                    imageSizeControls.style.display = 'flex';
                    imageEffectsControls.style.display = 'flex';
                    imagesContainer.style.display = 'block';
                    dwnlImgBtn.style.display = 'inline';
                    backgroundImg = img; // Keep for compatibility
                }
                
                renderImagesList();
                selectImage(id);
                updatePreview();
                return id;
            }
            
            function removeImage(id) {
                images = images.filter(i => i.id !== id);
                if (selectedImageId === id) {
                    selectedImageId = images.length > 0 ? images[0].id : null;
                }
                
                // Hide controls if no images
                if (images.length === 0) {
                    clearAllImagesBtn.style.display = 'none';
                    imageSizeControls.style.display = 'none';
                    imageEffectsControls.style.display = 'none';
                    imagesContainer.style.display = 'none';
                    dwnlImgBtn.style.display = 'none';
                    textBlocksContainer.style.display = 'none';
                    inputContainer.style.display = 'block';
                    multiTextCheckbox.checked = false;
                    backgroundImg = null;
                }
                
                renderImagesList();
                if (selectedImageId) selectImage(selectedImageId);
                updatePreview();
            }
            
            function selectImage(id) {
                selectedImageId = id;
                renderImagesList();
                updatePreview();
            }
            
            function updateImageCrop(id, cropX, cropY, cropW, cropH) {
                const imgObj = images.find(i => i.id === id);
                if (imgObj) {
                    imgObj.cropX = Math.max(0, Math.min(cropX, imgObj.origW - 1));
                    imgObj.cropY = Math.max(0, Math.min(cropY, imgObj.origH - 1));
                    imgObj.cropW = Math.max(1, Math.min(cropW, imgObj.origW - imgObj.cropX));
                    imgObj.cropH = Math.max(1, Math.min(cropH, imgObj.origH - imgObj.cropY));
                    updatePreview();
                }
            }
            
            function renderImagesList() {
                imagesList.innerHTML = '';
                images.forEach((imgObj, index) => {
                    const div = document.createElement('div');
                    div.className = 'image-item' + (imgObj.id === selectedImageId ? ' selected' : '');
                    const shortName = imgObj.name.length > 15 ? imgObj.name.substring(0, 12) + '...' : imgObj.name;
                    div.innerHTML = `
                        <span class="image-item-label" data-id="${imgObj.id}">${index + 1}. ${shortName}</span>
                        <button class="image-item-delete" data-id="${imgObj.id}">√ó</button>
                    `;
                    div.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('image-item-delete')) {
                            selectImage(imgObj.id);
                        }
                    });
                    imagesList.appendChild(div);
                });
                
                // Add delete listeners
                document.querySelectorAll('.image-item-delete').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        removeImage(parseInt(e.target.dataset.id));
                    });
                });
            }
            
            // Draw a single image with crop
            function drawImage(ctx, imgObj, applyFilter = true) {
                if (applyFilter) {
                    ctx.filter = `blur(${imageEffects.blur}px) contrast(${imageEffects.contrast}%) saturate(${imageEffects.saturation}%) brightness(${imageEffects.brightness}%)`;
                }
                // Draw cropped region of image at its position with scale
                const drawW = imgObj.cropW * imgObj.scale;
                const drawH = imgObj.cropH * imgObj.scale;
                ctx.drawImage(
                    imgObj.img,
                    imgObj.cropX, imgObj.cropY, imgObj.cropW, imgObj.cropH, // Source crop
                    imgObj.x, imgObj.y, drawW, drawH // Destination with scale
                );
                if (applyFilter) {
                    ctx.filter = 'none';
                }
                
                // Draw selection border for selected image
                if (imgObj.id === selectedImageId) {
                    ctx.strokeStyle = '#00aaff';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(imgObj.x, imgObj.y, drawW, drawH);
                    ctx.setLineDash([]);
                }
            }
            
            // Text block management functions
            function addTextBlock(text = '', x = 50, y = 100) {
                const id = ++textBlockIdCounter;
                textBlocks.push({ id, text, x, y });
                renderTextBlocksList();
                selectTextBlock(id);
                updatePreview();
                return id;
            }
            
            function removeTextBlock(id) {
                textBlocks = textBlocks.filter(b => b.id !== id);
                if (selectedTextBlockId === id) {
                    selectedTextBlockId = textBlocks.length > 0 ? textBlocks[0].id : null;
                }
                renderTextBlocksList();
                updatePreview();
            }
            
            function selectTextBlock(id, skipRender = false) {
                selectedTextBlockId = id;
                if (!skipRender) {
                    renderTextBlocksList();
                } else {
                    // Just update the visual selection without re-rendering
                    document.querySelectorAll('.text-block-item').forEach(item => {
                        const input = item.querySelector('.text-block-input');
                        if (input && parseInt(input.dataset.id) === id) {
                            item.classList.add('selected');
                        } else {
                            item.classList.remove('selected');
                        }
                    });
                }
            }
            
            function updateTextBlockContent(id, text) {
                const block = textBlocks.find(b => b.id === id);
                if (block) {
                    block.text = text;
                    updatePreview();
                }
            }
            
            function renderTextBlocksList() {
                textBlocksList.innerHTML = '';
                textBlocks.forEach((block, index) => {
                    const div = document.createElement('div');
                    div.className = 'text-block-item' + (block.id === selectedTextBlockId ? ' selected' : '');
                    div.innerHTML = `
                        <span class="text-block-label">Tekst ${index + 1}</span>
                        <textarea class="text-block-input" data-id="${block.id}" placeholder="Wpisz tekst...">${block.text}</textarea>
                        <button class="text-block-delete" data-id="${block.id}">√ó</button>
                    `;
                    div.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('text-block-delete') && !e.target.classList.contains('text-block-input')) {
                            selectTextBlock(block.id, true);
                            updatePreview();
                        }
                    });
                    textBlocksList.appendChild(div);
                });
                
                // Add event listeners
                document.querySelectorAll('.text-block-input').forEach(input => {
                    input.addEventListener('input', (e) => {
                        updateTextBlockContent(parseInt(e.target.dataset.id), e.target.value);
                    });
                    input.addEventListener('focus', (e) => {
                        selectTextBlock(parseInt(e.target.dataset.id), true);
                        updatePreview();
                    });
                });
                document.querySelectorAll('.text-block-delete').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        removeTextBlock(parseInt(e.target.dataset.id));
                    });
                });
            }
            
            // Helper to draw a single text block on canvas
            function drawTextBlock(ctx, block) {
                let text = block.text;
                if (processTextCheckbox.checked) {
                    text = processText(text);
                }
                
                ctx.font = `${settings.fontSize}px ${settings.fontFamily}`;
                ctx.textBaseline = 'top';
                const lines = (text || '').split('\n');
                const lineHeight = settings.fontSize + 5;
                
                lines.forEach((line, i) => {
                    const parsedLine = parseTextColor(line);
                    const y = block.y + i * lineHeight;
                    
                    // Draw text background if enabled
                    if (textBgEnabledCheckbox.checked && parsedLine.text) {
                        const textWidth = ctx.measureText(parsedLine.text).width;
                        const bgPadding = 4;
                        ctx.fillStyle = settings.bgColor;
                        ctx.fillRect(block.x - bgPadding, y - bgPadding, textWidth + bgPadding * 2, settings.fontSize + bgPadding * 2);
                    }
                    
                    // Draw sharp text outline by rendering text offset in 8 directions
                    ctx.fillStyle = 'black';
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            if (dx !== 0 || dy !== 0) {
                                ctx.fillText(parsedLine.text, block.x + dx, y + dy);
                            }
                        }
                    }
                    
                    // Draw text fill with parsed color
                    ctx.fillStyle = parsedLine.color;
                    ctx.fillText(parsedLine.text, block.x, y);
                });
                
                // Draw selection indicator for selected block
                if (block.id === selectedTextBlockId && lines.length > 0) {
                    const firstLine = lines[0] || '';
                    const parsedFirst = parseTextColor(firstLine);
                    const maxWidth = Math.max(...lines.map(l => ctx.measureText(parseTextColor(l).text).width));
                    const totalHeight = lines.length * lineHeight;
                    ctx.strokeStyle = '#fbf724';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(block.x - 5, block.y - 5, maxWidth + 10, totalHeight + 5);
                    ctx.setLineDash([]);
                }
            }
            
            // Function to parse text and return {text, color}
            function parseTextColor(line) {
                // Check for custom color markup: [color=#hex]...[/color]
                const colorTagRegex = /^\[color=(#[0-9a-fA-F]{3,6})\](.*)\[\/color\]$/;
                const match = line.match(colorTagRegex);
                if (match) {
                    return {
                        text: match[2],
                        color: match[1]
                    };
                }
                if (line.includes('(telefon)')) {
                    return {
                        text: line,
                        color: '#fbf724'
                    };
                } else if (line.includes('szepcze:')) {
                    return {
                        text: line,
                        color: '#a6a6a6'
                    };
                } else if (/\$\d+/.test(line)) {
                    return {
                        text: line,
                        color: '#56d64b'
                    };
                } else if (line.startsWith('**')) {
                    return {
                        text: line,
                        color: '#979aed'
                    };
                } else if (line.startsWith('*')) {
                    return {
                        text: line,
                        color: '#c2a3da'
                    };
                } else {
                    return {
                        text: line,
                        color: '#f1f1f1'
                    };
                }
            }
            
            // Function to process text - remove timestamps and reverse order
            function processText(text) {
                const lines = text.split('\n');
                const filteredLines = lines.filter(line => {
                    return !/^\d{2}\/\d{2}\/\d{2}\s+\d{2}:\d{2}:\d{2}$/.test(line.trim()) && !line.trim().startsWith('/');
                });
                return filteredLines.reverse().join('\n');
            }
            
            // Function to create image with text and transparent background
            function createTransparentImage(text) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                const fontSize = settings.fontSize;
                const fontFamily = settings.fontFamily;
                const lineHeight = fontSize + 5;
                const padding = 13;
                const maxWidth = settings.maxWidth;
                
                ctx.font = `${fontSize}px ${fontFamily}`;
                
                const textLines = text.split('\n');
                const lines = [];
                
                for (let textLine of textLines) {
                    if (textLine === '') {
                        lines.push('');
                        continue;
                    }
                    
                    const words = textLine.split(' ');
                    let currentLine = '';
                    
                    for (let word of words) {
                        const testLine = currentLine + (currentLine ? ' ' : '') + word;
                        const metrics = ctx.measureText(testLine);
                        
                        if (metrics.width > maxWidth - padding * 2 && currentLine) {
                            lines.push(currentLine);
                            currentLine = word;
                        } else {
                            currentLine = testLine;
                        }
                    }
                    if (currentLine) lines.push(currentLine);
                }
                
                let actualWidth = 0;
                lines.forEach(line => {
                    const parsedLine = parseTextColor(line);
                    const metrics = ctx.measureText(parsedLine.text);
                    actualWidth = Math.max(actualWidth, metrics.width);
                });
                
                canvas.width = Math.max(Math.min(actualWidth + padding * 2, maxWidth), 100);
                canvas.height = Math.max(lineHeight * lines.length + padding * 2, 50);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = `${fontSize}px ${fontFamily}`;
                ctx.textBaseline = 'top';
                ctx.fillStyle = 'black';
                
                lines.forEach((line, index) => {
                    const parsedLine = parseTextColor(line);
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            if (dx !== 0 || dy !== 0) {
                                ctx.fillText(parsedLine.text, padding + dx, padding + index * lineHeight + dy);
                            }
                        }
                    }
                });
                
                lines.forEach((line, index) => {
                    const parsedLine = parseTextColor(line);
                    ctx.fillStyle = parsedLine.color;
                    ctx.fillText(parsedLine.text, padding, padding + index * lineHeight);
                });
                
                return canvas;
            }
            
            // Function to convert text to image with background
            function textToImage(text, canvas = null) {
                if (!canvas) {
                    canvas = document.createElement('canvas');
                }
                const ctx = canvas.getContext('2d');
                
                const fontSize = settings.fontSize;
                const fontFamily = settings.fontFamily;
                const lineHeight = fontSize + 5;
                const padding = 13;
                const maxWidth = settings.maxWidth;
                
                ctx.font = `${fontSize}px ${fontFamily}`;
                
                const textLines = (text || '').split('\n');
                const lines = [];
                
                for (let textLine of textLines) {
                    if (textLine === '') {
                        lines.push('');
                        continue;
                    }
                    
                    const words = textLine.split(' ');
                    let currentLine = '';
                    
                    for (let word of words) {
                        const testLine = currentLine + (currentLine ? ' ' : '') + word;
                        const metrics = ctx.measureText(testLine);
                        
                        if (metrics.width > maxWidth - padding * 2 && currentLine) {
                            lines.push(currentLine);
                            currentLine = word;
                        } else {
                            currentLine = testLine;
                        }
                    }
                    if (currentLine) lines.push(currentLine);
                }
                
                // If no lines, add a placeholder
                if (lines.length === 0) {
                    lines.push('');
                }
                
                let actualWidth = 0;
                lines.forEach(line => {
                    const parsedLine = parseTextColor(line);
                    const metrics = ctx.measureText(parsedLine.text);
                    actualWidth = Math.max(actualWidth, metrics.width);
                });
                
                // Ensure minimum canvas size
                canvas.width = Math.max(Math.min(actualWidth + padding * 2, maxWidth), 200);
                canvas.height = Math.max(lineHeight * lines.length + padding * 2, 50);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = `${fontSize}px ${fontFamily}`;
                ctx.textBaseline = 'top';
                
                // Draw backgrounds
                ctx.fillStyle = settings.bgColor;
                lines.forEach((line, index) => {
                    const parsedLine = parseTextColor(line);
                    const textWidth = ctx.measureText(parsedLine.text).width;
                    const bgPadding = 4;
                    if (parsedLine.text) {
                        ctx.fillRect(padding - bgPadding, padding + index * lineHeight - bgPadding, textWidth + bgPadding * 2, fontSize + bgPadding * 2);
                    }
                });
                
                // Draw outlines
                ctx.fillStyle = 'black';
                lines.forEach((line, index) => {
                    const parsedLine = parseTextColor(line);
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            if (dx !== 0 || dy !== 0) {
                                ctx.fillText(parsedLine.text, padding + dx, padding + index * lineHeight + dy);
                            }
                        }
                    }
                });
                
                // Draw text
                lines.forEach((line, index) => {
                    const parsedLine = parseTextColor(line);
                    ctx.fillStyle = parsedLine.color;
                    ctx.fillText(parsedLine.text, padding, padding + index * lineHeight);
                });
                
                return canvas;
            }
            
            // Function to update preview
            function updatePreview() {
                let text = userInput.value;
                if (processTextCheckbox.checked) {
                    text = processText(text);
                }
                
                if (images.length > 0) {
                    // Use viewport size for canvas
                    previewCanvas.width = viewportSize.width;
                    previewCanvas.height = viewportSize.height;
                    const ctx = previewCanvas.getContext('2d');
                    ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                    
                    // Draw all images in order
                    images.forEach(imgObj => {
                        drawImage(ctx, imgObj, true);
                    });
                    
                    // Draw crop rectangle if cropping
                    if (isCropping && selectedImageId) {
                        const imgObj = images.find(i => i.id === selectedImageId);
                        if (imgObj) {
                            const minX = Math.min(cropStart.x, cropEnd.x);
                            const maxX = Math.max(cropStart.x, cropEnd.x);
                            const minY = Math.min(cropStart.y, cropEnd.y);
                            const maxY = Math.max(cropStart.y, cropEnd.y);
                            
                            // Convert image coords to canvas coords
                            const rectX = imgObj.x + (minX - imgObj.cropX) * imgObj.scale;
                            const rectY = imgObj.y + (minY - imgObj.cropY) * imgObj.scale;
                            const rectW = (maxX - minX) * imgObj.scale;
                            const rectH = (maxY - minY) * imgObj.scale;
                            
                            // Draw semi-transparent overlay outside crop area
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                            ctx.fillRect(0, 0, previewCanvas.width, rectY);
                            ctx.fillRect(0, rectY, rectX, rectH);
                            ctx.fillRect(rectX + rectW, rectY, previewCanvas.width - rectX - rectW, rectH);
                            ctx.fillRect(0, rectY + rectH, previewCanvas.width, previewCanvas.height - rectY - rectH);
                            
                            // Draw crop border
                            ctx.strokeStyle = '#00ff00';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([5, 5]);
                            ctx.strokeRect(rectX, rectY, rectW, rectH);
                            ctx.setLineDash([]);
                        }
                    }
                    
                    // Apply grain effect
                    if (imageEffects.grain > 0) {
                        applyGrain(ctx, previewCanvas.width, previewCanvas.height, imageEffects.grain);
                    }
                    
                    // Draw text based on mode
                    if (multiTextCheckbox.checked) {
                        // Draw all text blocks
                        textBlocks.forEach(block => {
                            drawTextBlock(ctx, block);
                        });
                    } else {
                        // Single text mode - use the main textarea
                        drawTextBlock(ctx, { id: 0, text: text, x: textPosition.x, y: textPosition.y });
                    }
                    
                    // Scale preview display to 80% (20% smaller)
                    previewCanvas.style.width = (previewCanvas.width * 0.8) + 'px';
                    previewCanvas.style.height = (previewCanvas.height * 0.8) + 'px';
                } else {
                    textToImage(text, previewCanvas);
                    previewCanvas.style.width = previewCanvas.width + 'px';
                    previewCanvas.style.height = previewCanvas.height + 'px';
                }
            }
            
            // Function to create image with background image and text (for download)
            function createImageWithBackground() {
                const canvas = document.createElement('canvas');
                canvas.width = viewportSize.width;
                canvas.height = viewportSize.height;
                const ctx = canvas.getContext('2d');
                
                // Temporarily hide selections
                const originalSelectedImage = selectedImageId;
                const originalSelectedText = selectedTextBlockId;
                selectedImageId = null;
                selectedTextBlockId = null;
                
                // Draw all images
                images.forEach(imgObj => {
                    drawImage(ctx, imgObj, true);
                });
                
                // Apply grain effect
                if (imageEffects.grain > 0) {
                    applyGrain(ctx, canvas.width, canvas.height, imageEffects.grain);
                }
                
                // Draw text based on mode
                if (multiTextCheckbox.checked) {
                    textBlocks.forEach(block => {
                        drawTextBlock(ctx, block);
                    });
                } else {
                    // Single text mode
                    let text = userInput.value;
                    if (processTextCheckbox.checked) {
                        text = processText(text);
                    }
                    drawTextBlock(ctx, { id: 0, text: text, x: textPosition.x, y: textPosition.y });
                }
                
                // Restore selections
                selectedImageId = originalSelectedImage;
                selectedTextBlockId = originalSelectedText;
                
                return canvas;
            }
            
            // Function to add message to chat
            function addMessageToChat(text) {
                let processedText = text;
                if (processTextCheckbox.checked) {
                    processedText = processText(text);
                }
                if (!processedText.trim()) return;
                
                const messageDiv = document.createElement('div');
                messageDiv.className = 'chat_message';
                
                const canvas = textToImage(processedText);
                const imageUrl = canvas.toDataURL('image/png');
                const img = document.createElement('img');
                img.src = imageUrl;
                img.alt = 'Message image';
                
                messageDiv.appendChild(img);
                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            // --- EVENT LISTENERS (after functions are defined) ---
            
            // Always update preview on input/settings change
            userInput.addEventListener('input', updatePreview);
            fontSizeInput.addEventListener('input', function() {
                settings.fontSize = parseInt(this.value);
                fontSizeDisplay.textContent = this.value + 'px';
                updatePreview();
            });
            bgColorInput.addEventListener('change', function() {
                settings.bgColor = this.value;
                updatePreview();
            });
            fontFamilyInput.addEventListener('change', function() {
                settings.fontFamily = this.value;
                updatePreview();
            });
            processTextCheckbox.addEventListener('change', updatePreview);

            // Custom file button click
            bgImageBtn.addEventListener('click', function() {
                bgImageInput.click();
            });

            // Background image upload
            bgImageInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(ev) {
                    const img = new window.Image();
                    img.onload = function() {
                        addImage(img, file.name);
                    };
                    img.src = ev.target.result;
                };
                reader.readAsDataURL(file);
                
                // Reset input to allow adding same file again
                bgImageInput.value = '';
            });
            
            // Text background checkbox
            textBgEnabledCheckbox.addEventListener('change', updatePreview);
            
            // Multiple text checkbox
            multiTextCheckbox.addEventListener('change', function() {
                if (this.checked) {
                    // Show text blocks, hide single input
                    textBlocksContainer.style.display = 'block';
                    inputContainer.style.display = 'none';
                    // Add initial block if none exist
                    if (textBlocks.length === 0) {
                        addTextBlock('', 50, 100);
                    }
                } else {
                    // Hide text blocks, show single input
                    textBlocksContainer.style.display = 'none';
                    inputContainer.style.display = 'block';
                }
                updatePreview();
            });
            
            // Clear all images
            clearAllImagesBtn.addEventListener('click', function() {
                images = [];
                selectedImageId = null;
                imageIdCounter = 0;
                backgroundImg = null;
                originalBackgroundImg = null;
                bgImageInput.value = '';
                clearAllImagesBtn.style.display = 'none';
                imageSizeControls.style.display = 'none';
                imageEffectsControls.style.display = 'none';
                imagesContainer.style.display = 'none';
                textBlocksContainer.style.display = 'none';
                inputContainer.style.display = 'block';
                dwnlImgBtn.style.display = 'none';
                textBgEnabledCheckbox.checked = false;
                multiTextCheckbox.checked = false;
                // Clear text blocks
                textBlocks = [];
                selectedTextBlockId = null;
                textBlockIdCounter = 0;
                renderTextBlocksList();
                renderImagesList();
                // Reset effects
                imageEffects = { blur: 0, contrast: 100, saturation: 100, brightness: 100, grain: 0 };
                effectBlur.value = 0; blurValue.textContent = '0';
                effectContrast.value = 100; contrastValue.textContent = '100';
                effectSaturation.value = 100; saturationValue.textContent = '100';
                effectBrightness.value = 100; brightnessValue.textContent = '100';
                effectGrain.value = 0; grainValue.textContent = '0';
                imagePosition = { x: 0, y: 0 };
                viewportSize = { width: 800, height: 600 };
                updatePreview();
            });
            
            // Apply output size (viewport)
            applySizeBtn.addEventListener('click', function() {
                if (!backgroundImg) return;
                const newWidth = parseInt(imageWidthInput.value);
                const newHeight = parseInt(imageHeightInput.value);
                if (newWidth < 100 || newHeight < 100) {
                    alert('Minimum size is 100x100');
                    return;
                }
                
                viewportSize = { width: newWidth, height: newHeight };
                updatePreview();
            });

            // Image effects listeners
            effectBlur.addEventListener('input', function() {
                imageEffects.blur = parseInt(this.value);
                blurValue.textContent = this.value;
                updatePreview();
            });
            effectContrast.addEventListener('input', function() {
                imageEffects.contrast = parseInt(this.value);
                contrastValue.textContent = this.value;
                updatePreview();
            });
            effectSaturation.addEventListener('input', function() {
                imageEffects.saturation = parseInt(this.value);
                saturationValue.textContent = this.value;
                updatePreview();
            });
            effectBrightness.addEventListener('input', function() {
                imageEffects.brightness = parseInt(this.value);
                brightnessValue.textContent = this.value;
                updatePreview();
            });
            effectGrain.addEventListener('input', function() {
                imageEffects.grain = parseInt(this.value);
                grainValue.textContent = this.value;
                updatePreview();
            });
            resetEffectsBtn.addEventListener('click', function() {
                imageEffects = { blur: 0, contrast: 100, saturation: 100, brightness: 100, grain: 0 };
                effectBlur.value = 0; blurValue.textContent = '0';
                effectContrast.value = 100; contrastValue.textContent = '100';
                effectSaturation.value = 100; saturationValue.textContent = '100';
                effectBrightness.value = 100; brightnessValue.textContent = '100';
                effectGrain.value = 0; grainValue.textContent = '0';
                updatePreview();
            });

            // Add text block button
            addTextBlockBtn.addEventListener('click', function() {
                // Add new block at a slightly offset position
                const offsetY = textBlocks.length * 30;
                addTextBlock('', 50, 100 + offsetY);
            });

            // Mouse events for dragging text and image
            previewCanvas.addEventListener('mousedown', function(e) {
                const rect = previewCanvas.getBoundingClientRect();
                const scaleX = previewCanvas.width / rect.width;
                const scaleY = previewCanvas.height / rect.height;
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;
                
                // Ctrl+click to start cropping selected image
                if (images.length > 0 && e.ctrlKey && e.button === 0 && selectedImageId) {
                    const imgObj = images.find(i => i.id === selectedImageId);
                    if (imgObj) {
                        // Convert canvas coords to image coords
                        const imgX = (mouseX - imgObj.x) / imgObj.scale;
                        const imgY = (mouseY - imgObj.y) / imgObj.scale;
                        
                        // Start crop from current mouse position (relative to original image)
                        isCropping = true;
                        cropStart.x = Math.max(0, Math.min(imgObj.origW, imgObj.cropX + imgX));
                        cropStart.y = Math.max(0, Math.min(imgObj.origH, imgObj.cropY + imgY));
                        cropEnd.x = cropStart.x;
                        cropEnd.y = cropStart.y;
                        e.preventDefault();
                        return;
                    }
                }

                // Shift+click or right-click to drag selected image
                if (images.length > 0 && (e.shiftKey || e.button === 2)) {
                    // Check if clicking on an image (in reverse order for z-index)
                    for (let i = images.length - 1; i >= 0; i--) {
                        const imgObj = images[i];
                        const drawW = imgObj.cropW * imgObj.scale;
                        const drawH = imgObj.cropH * imgObj.scale;
                        if (mouseX >= imgObj.x && mouseX <= imgObj.x + drawW &&
                            mouseY >= imgObj.y && mouseY <= imgObj.y + drawH) {
                            selectImage(imgObj.id);
                            isImageDragging = true;
                            dragOffset.x = mouseX - imgObj.x;
                            dragOffset.y = mouseY - imgObj.y;
                            e.preventDefault();
                            return;
                        }
                    }
                    e.preventDefault();
                    return;
                }
                
                // Handle text block dragging - check all blocks and select/drag the clicked one
                if (images.length === 0) return;
                
                const ctx = previewCanvas.getContext('2d');
                ctx.font = `${settings.fontSize}px ${settings.fontFamily}`;
                const lineHeight = settings.fontSize + 5;
                
                // Single text mode
                if (!multiTextCheckbox.checked) {
                    let singleText = userInput.value;
                    if (processTextCheckbox.checked) {
                        singleText = processText(singleText);
                    }
                    const lines = (singleText || '').split('\n');
                    
                    let maxWidth = 0;
                    lines.forEach(line => {
                        const parsed = parseTextColor(line);
                        const w = ctx.measureText(parsed.text).width;
                        if (w > maxWidth) maxWidth = w;
                    });
                    const totalHeight = lines.length * lineHeight;
                    
                    if (
                        mouseX >= textPosition.x - 5 &&
                        mouseX <= textPosition.x + maxWidth + 5 &&
                        mouseY >= textPosition.y - 5 &&
                        mouseY <= textPosition.y + totalHeight + 5
                    ) {
                        isDragging = true;
                        dragOffset.x = mouseX - textPosition.x;
                        dragOffset.y = mouseY - textPosition.y;
                    }
                    return;
                }
                
                // Multiple text mode - check each text block (in reverse to prioritize top-most/last added)
                for (let b = textBlocks.length - 1; b >= 0; b--) {
                    const block = textBlocks[b];
                    let blockText = block.text;
                    if (processTextCheckbox.checked) {
                        blockText = processText(blockText);
                    }
                    const lines = (blockText || '').split('\n');
                    
                    // Calculate block bounds
                    let maxWidth = 0;
                    lines.forEach(line => {
                        const parsed = parseTextColor(line);
                        const w = ctx.measureText(parsed.text).width;
                        if (w > maxWidth) maxWidth = w;
                    });
                    const totalHeight = lines.length * lineHeight;
                    
                    if (
                        mouseX >= block.x - 5 &&
                        mouseX <= block.x + maxWidth + 5 &&
                        mouseY >= block.y - 5 &&
                        mouseY <= block.y + totalHeight + 5
                    ) {
                        selectTextBlock(block.id);
                        isDragging = true;
                        dragOffset.x = mouseX - block.x;
                        dragOffset.y = mouseY - block.y;
                        updatePreview();
                        break;
                    }
                }
            });
            
            // Prevent context menu on canvas for right-click dragging
            previewCanvas.addEventListener('contextmenu', function(e) {
                if (images.length > 0) {
                    e.preventDefault();
                }
            });
            
            // Mouse wheel + Alt to scale selected image
            previewCanvas.addEventListener('wheel', function(e) {
                if (!e.altKey) return; // Only scale when Alt is held
                if (images.length === 0 || !selectedImageId) return;
                
                const imgObj = images.find(i => i.id === selectedImageId);
                if (!imgObj) return;
                
                // Check if mouse is over the selected image
                const rect = previewCanvas.getBoundingClientRect();
                const scaleX = previewCanvas.width / rect.width;
                const scaleY = previewCanvas.height / rect.height;
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;
                
                const drawW = imgObj.cropW * imgObj.scale;
                const drawH = imgObj.cropH * imgObj.scale;
                
                if (mouseX >= imgObj.x && mouseX <= imgObj.x + drawW &&
                    mouseY >= imgObj.y && mouseY <= imgObj.y + drawH) {
                    e.preventDefault();
                    
                    // Scale factor based on scroll direction
                    const scaleDelta = e.deltaY > 0 ? 0.95 : 1.05;
                    const newScale = Math.max(0.1, Math.min(10, imgObj.scale * scaleDelta));
                    
                    // Scale around mouse position
                    const mouseRelX = mouseX - imgObj.x;
                    const mouseRelY = mouseY - imgObj.y;
                    const scaleRatio = newScale / imgObj.scale;
                    
                    imgObj.x = mouseX - mouseRelX * scaleRatio;
                    imgObj.y = mouseY - mouseRelY * scaleRatio;
                    imgObj.scale = newScale;
                    
                    updatePreview();
                }
            }, { passive: false });
            
            window.addEventListener('mousemove', function(e) {
                const rect = previewCanvas.getBoundingClientRect();
                const scaleX = previewCanvas.width / rect.width;
                const scaleY = previewCanvas.height / rect.height;
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;
                
                // Handle cropping
                if (isCropping && selectedImageId) {
                    const imgObj = images.find(i => i.id === selectedImageId);
                    if (imgObj) {
                        // Convert canvas coords to original image coords
                        const imgX = (mouseX - imgObj.x) / imgObj.scale;
                        const imgY = (mouseY - imgObj.y) / imgObj.scale;
                        cropEnd.x = Math.max(0, Math.min(imgObj.origW, imgObj.cropX + imgX));
                        cropEnd.y = Math.max(0, Math.min(imgObj.origH, imgObj.cropY + imgY));
                        updatePreview();
                    }
                    return;
                }
                
                // Handle image dragging
                if (isImageDragging && selectedImageId) {
                    const imgObj = images.find(i => i.id === selectedImageId);
                    if (imgObj) {
                        imgObj.x = mouseX - dragOffset.x;
                        imgObj.y = mouseY - dragOffset.y;
                        updatePreview();
                    }
                    return;
                }
                
                // Handle text dragging
                if (!isDragging) return;
                
                // Single text mode
                if (!multiTextCheckbox.checked) {
                    textPosition.x = mouseX - dragOffset.x;
                    textPosition.y = mouseY - dragOffset.y;
                    updatePreview();
                    return;
                }
                
                // Multiple text mode - drag selected block
                if (!selectedTextBlockId) return;
                const block = textBlocks.find(b => b.id === selectedTextBlockId);
                if (block) {
                    block.x = mouseX - dragOffset.x;
                    block.y = mouseY - dragOffset.y;
                    updatePreview();
                }
            });
            window.addEventListener('mouseup', function(e) {
                // Finalize cropping
                if (isCropping && selectedImageId) {
                    const imgObj = images.find(i => i.id === selectedImageId);
                    if (imgObj) {
                        const minX = Math.min(cropStart.x, cropEnd.x);
                        const maxX = Math.max(cropStart.x, cropEnd.x);
                        const minY = Math.min(cropStart.y, cropEnd.y);
                        const maxY = Math.max(cropStart.y, cropEnd.y);
                        
                        const newCropW = maxX - minX;
                        const newCropH = maxY - minY;
                        
                        // Only apply if crop area is meaningful (at least 10px)
                        if (newCropW >= 10 && newCropH >= 10) {
                            imgObj.cropX = Math.round(minX);
                            imgObj.cropY = Math.round(minY);
                            imgObj.cropW = Math.round(newCropW);
                            imgObj.cropH = Math.round(newCropH);
                            // Reset position to origin after crop
                            imgObj.x = 0;
                            imgObj.y = 0;
                        }
                        updatePreview();
                    }
                }
                
                isDragging = false;
                isImageDragging = false;
                isCropping = false;
            });

            // Text color selection handler
            customColorInput.addEventListener('input', function() {
                // Determine which textarea to use based on mode
                let textarea;
                if (multiTextCheckbox.checked && selectedTextBlockId !== null) {
                    textarea = document.querySelector(`.text-block-input[data-id="${selectedTextBlockId}"]`);
                } else {
                    textarea = userInput;
                }
                
                if (!textarea) {
                    updatePreview();
                    return;
                }
                
                const color = customColorInput.value;
                let start = textarea.selectionStart;
                let end = textarea.selectionEnd;
                if (start === end) {
                    // Nothing selected, just update preview
                    updatePreview();
                    return;
                }
                let value = textarea.value;

                const before = value.substring(0, start);
                const selected = value.substring(start, end);
                const after = value.substring(end);

                const colorTagRegex = /\[color=#[0-9a-fA-F]{3,6}\]([\s\S]*?)\[\/color\]/g;
                let match, found = false;
                let newValue = value;
                while ((match = colorTagRegex.exec(value)) !== null) {
                    const tagStart = match.index;
                    const tagEnd = colorTagRegex.lastIndex;
                    const innerStart = tagStart + match[0].indexOf(match[1]);
                    const innerEnd = innerStart + match[1].length;
                    if (start >= innerStart && end <= innerEnd) {
                        const newTag = '[color=' + color + ']' + match[1] + '[/color]';
                        newValue = value.substring(0, tagStart) + newTag + value.substring(tagEnd);
                        textarea.value = newValue;
                        textarea.selectionStart = start + (newTag.length - match[0].length);
                        textarea.selectionEnd = end + (newTag.length - match[0].length);
                        textarea.focus();
                        // Update the block's text if in multi-text mode
                        if (multiTextCheckbox.checked && selectedTextBlockId !== null) {
                            updateTextBlockContent(selectedTextBlockId, textarea.value);
                        } else {
                            updatePreview();
                        }
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    textarea.value = before + '[color=' + color + ']' + selected + '[/color]' + after;
                    textarea.selectionStart = before.length + ('[color=' + color + ']').length;
                    textarea.selectionEnd = textarea.selectionStart + selected.length;
                    textarea.focus();
                    // Update the block's text if in multi-text mode
                    if (multiTextCheckbox.checked && selectedTextBlockId !== null) {
                        updateTextBlockContent(selectedTextBlockId, textarea.value);
                    } else {
                        updatePreview();
                    }
                }
            });

            // Handle Enter key
            userInput.addEventListener('keydown', function(event) {
                if (event.ctrlKey && event.key === 'Enter') {
                    event.preventDefault();
                    const text = userInput.value;
                    addMessageToChat(text);
                    userInput.value = '';
                    updatePreview();
                } else if (event.key === 'Enter' && !event.ctrlKey) {
                    event.preventDefault();
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    const text = this.value;
                    this.value = text.substring(0, start) + '\n' + text.substring(end);
                    this.selectionStart = this.selectionEnd = start + 1;
                    updatePreview();
                }
            });

            // Download buttons
            dwnlTrsBtn.addEventListener('click', function() {
                let text = userInput.value;
                if (processTextCheckbox.checked) {
                    text = processText(text);
                }
                if (!text.trim()) {
                    alert('Please enter some text first!');
                    return;
                }
                const canvas = createTransparentImage(text);
                const link = document.createElement('a');
                link.href = canvas.toDataURL('image/png');
                link.download = 'message_transparent.png';
                link.click();
            });

            dwnlBcgBtn.addEventListener('click', function() {
                let text = userInput.value;
                if (processTextCheckbox.checked) {
                    text = processText(text);
                }
                if (!text.trim()) {
                    alert('Please enter some text first!');
                    return;
                }
                const canvas = textToImage(text);
                const link = document.createElement('a');
                link.href = canvas.toDataURL('image/png');
                link.download = 'message_background.png';
                link.click();
            });
            
            // Download with background image
            dwnlImgBtn.addEventListener('click', function() {
                let text = userInput.value;
                if (processTextCheckbox.checked) {
                    text = processText(text);
                }
                if (images.length === 0) {
                    alert('Najpierw dodaj obraz!');
                    return;
                }
                const canvas = createImageWithBackground(text);
                const link = document.createElement('a');
                link.href = canvas.toDataURL('image/png');
                link.download = 'message_with_image.png';
                link.click();
            });

            // Initialize preview on load
            window.addEventListener('DOMContentLoaded', function() {
                updatePreview();
            });
            
            // Also call updatePreview immediately in case DOM is already loaded
            updatePreview();
        </script>
    </body>
</html>
